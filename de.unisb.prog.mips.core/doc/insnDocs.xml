<?xml version="1.0" encoding="UTF-8"?>
<instructions>
	<group name="Arithmetic and Logic">
		<insn mnemonic="addi"    short="add immediate"                    purpose="dst &lt;- op + imm" exceptions="integer overflow">Immediate is sign extended</insn>
		<insn mnemonic="addiu"   short="add immediate unsigned"           purpose="dst &lt;- op + imm">Immediate is sign extended</insn>
		<insn mnemonic="andi"    short="and immediate"                    purpose="dst &lt;- op1 and imm">Immediate is not sign extended</insn>
		<insn mnemonic="ori"     short="or immediate"                     purpose="dst &lt;- op1 or imm">Immediate is not sign extended</insn>
		<insn mnemonic="xori"    short="xor immediate"                    purpose="dst &lt;- op1 xor imm">Immediate is not sign extended</insn>
		<insn mnemonic="lui"     short="load upper 16 bit with immediate" purpose="dst &lt;- imm &lt;&lt; 16"> </insn>
		
		<insn mnemonic="add"     short="add signed"                       purpose="dst &lt;- op1 + op2"   exceptions="integer overflow"> </insn>
		<insn mnemonic="addu"    short="add unsigned"                     purpose="dst &lt;- op1 + op2">No exception thrown upon overflow</insn>
		<insn mnemonic="sub"     short="subtract signed"                  purpose="dst &lt;- op1 - op2"   exceptions="integer overflow"> </insn>
		<insn mnemonic="subu"    short="subtract unsigned"                purpose="dst &lt;- op1 - op2">No exception thrown. </insn>
		<insn mnemonic="and"     short="bitwise and"                      purpose="dst &lt;- op1 &amp; op2"> </insn>
		<insn mnemonic="or"      short="bitwise or"                       purpose="dst &lt;- op1 | op2"> </insn>
		<insn mnemonic="nor"     short="bitwise nor"                      purpose="dst &lt;- ~(op1 | op2)"> </insn>
		<insn mnemonic="xor"     short="bitwise xor"                      purpose="dst &lt;- op1 ^ op2"> </insn>
		
		<insn mnemonic="sll"     short="shift left by immediate"             purpose="dst &lt;- op &lt;&lt; imm"> </insn>
		<insn mnemonic="srl"     short="shift right logically by immediate"  purpose="dst &lt;- op &gt;&gt;&gt; imm">
		  The operand is shifted right by imm bits. 
		  The most significant bit is filled with 0.
		</insn>
		<insn mnemonic="sra"     short="shift right arithmetically by immediate" purpose="dst &lt;- op &gt;&gt; op2">
  		  The operand is shifted right by imm bits.
		  The most significant bit is replicated.
	    </insn>
	    
		<insn mnemonic="sllv"    short="shift left by register"            purpose="dst &lt;- op1 &lt;&lt; op2"> </insn>
		<insn mnemonic="srlv"    short="shift right logically by register" purpose="dst &lt;- op1 &gt;&gt;&gt; op2">
		  The operand is shifted right by op2 bits. 
		  The most significant bit is filled with 0.
		</insn>
		<insn mnemonic="srav"    short="shift right arithmetically by register"  purpose="dst &lt;- op1 &gt;&gt; op2">
  		  The operand is shifted right by op2 bits.
		  The most significant bit is replicated.
	    </insn>
		
		
		<insn mnemonic="div"     short="signed division"                   purpose="lo &lt;- op1 / op2; hi &lt;- reminder of op1 / op2"> </insn>
		<insn mnemonic="divu"    short="unsigned division"                 purpose="lo &lt;- op1 / op2; hi &lt;- reminder of op1 / op2"> 
		  op1 and op2 are interpreted as unsigned integers.
		</insn>
		<insn mnemonic="mult"    short="signed multiplication"             purpose="lo &lt;- lower_32_bit(op1 * op2); hi &lt;- higher_32_bit(op1 * op2)"> </insn>
		<insn mnemonic="multu"   short="unsigned multiplication"           purpose="lo &lt;- lower_32_bit(op1 * op2); hi &lt;- higher_32_bit(op1 * op2)"> 
		  op1 and op2 are interpreted as unsigned integers.
		</insn>
		
		<insn mnemonic="mflo"    short="move from lo register"             purpose="dst &lt;- lo"></insn>
		<insn mnemonic="mfhi"    short="move from hi register"             purpose="dst &lt;- hi"></insn>
		<insn mnemonic="mtlo"    short="move to lo register"               purpose="lo &lt;- op"></insn>
		<insn mnemonic="mthi"    short="move to hi register"               purpose="hi &lt;- op"></insn>
	</group>
	
	<group name="Constant-Manipulation">
		<insn mnemonic="li"      short="load immediate" purpose="dst &lt;- 32-bit constant">
			Load a 32-bit constant into register dst. 
			This might generate multiple machine instructions.
		</insn>
	
		<insn mnemonic="la"      short="load address"   purpose="dst &lt;- 32-bit label">
			Load address of a label into register dst.
			This might generate multiple machine instructions.
		</insn>
	</group>
	
	<group name="Comparison">
		<insn mnemonic="slt"    short="set if less than"           purpose="dst &lt;- if op1 &lt; op2 then 1 else 0"> </insn>
		<insn mnemonic="slti"   short="set if less than immediate" purpose="dst &lt;- if op1 &lt; imm then 1 else 0"> </insn>
		<insn mnemonic="sltu"   short="set if less than (unsigned comparison)" purpose="dst &lt; if op1 &lt; op2 then 1 else 0">op1 and op2 are interpreted as unsigned numbers.</insn>
		<insn mnemonic="sltiu"  short="set if less than immediate (unsigned comparison)" purpose="dst &lt;- if op1 &lt; imm then 1 else 0">op1 and imm are interpreted as unsigned numbers</insn>
	</group>
	
	<group name="Branching and Jumping">
		<insn mnemonic="beq"  short="branch if equal"                 purpose="if op1 == op2 then pc &lt;- pc + offset"> </insn>
		<insn mnemonic="bne"  short="branch if unequal"               purpose="if op1 != op2 then pc &lt;- pc + offset"> </insn>
		<insn mnemonic="bgez" short="branch if greater or equal to 0" purpose="if op &gt;= 0 then pc &lt;- pc + offset"> </insn>
		<insn mnemonic="bgtz" short="branch if greater than 0"        purpose="if op &gt; 0 then pc &lt;- pc + offset"> </insn>
		<insn mnemonic="blez" short="branch if less or equal to 0"    purpose="if op &lt;= 0 then pc &lt;- pc + offset"> </insn>
		<insn mnemonic="bltz" short="branch if less than 0"           purpose="if op &lt; 0 then pc &lt;- pc + offset"> </insn>
		<insn mnemonic="j"    short="jump to abolsute address"        purpose="pc &lt;- address"></insn>
		<insn mnemonic="jal"  short="procedure call"                  purpose="$ra &lt;- pc + 4; pc &lt;- address"></insn>
		<insn mnemonic="jr"   short="jump to address in register"     purpose="pc &lt;- op"></insn>
		<insn mnemonic="jalr" short="jump to address in register and link"  purpose="dst &lt;- pc + 4; pc &lt;- op">
		  Indirect procedure call. 
		  If no destination register is given, $ra is used.
		</insn>
	</group>
	
	<group name="Exceptions, Interrupts and Traps">
		<insn mnemonic="syscall" short="enter operating system" purpose="syscall">
Register $v0 contains the number of the system call. 
		</insn>
		<insn mnemonic="brk" short="break to the debugger" purpose="brk"> </insn>
	</group>
	
	<group name="Memory Loads and Stores">
		<insn mnemonic="lw"    short="load word"              purpose="dst &lt;- load 4 bytes from base + offset"> </insn>
		<insn mnemonic="lh"    short="load halfword"          purpose="dst &lt;- load 2 bytes from base + offset and sign extend"> </insn>
		<insn mnemonic="lb"    short="load byte"              purpose="dst &lt;- load 1 byte from base + offset and sign extend"> </insn>
		<insn mnemonic="lhu"   short="load unsigned halfword" purpose="dst &lt;- load 2 bytes from base + offset and do not sign extend"> </insn>
		<insn mnemonic="lbu"   short="load unsigned byte"     purpose="dst &lt;- load 1 byte from base + offset and do not sign extend"> </insn>
	</group>
	
</instructions>