<?xml version="1.0" encoding="UTF-8"?>
<instructions>
	<group name="Arithmetic and Logic">
		<insn mnemonic="add" 
		      purpose="Add two 32-bit integers. Trap on overflow."
		      exceptions="Integer overflow.">
	The 32-bit word value in register rt is added to the 32-bit value in
	register rs to produce a 32-bit result.
	If the addition results in 32-bit 2’s complement arithmetic overflow then
	the destination register is not modified and an Integer Overflow
	exception occurs. If it does not overflow, the 32-bit result is placed
	into GPR rd.
		</insn>
		
		<insn mnemonic="addi" 
		      purpose="Add a constant to a 32-bit integer. If overflow occurs, then trap."
		      exceptions="Integer overflow.">
	The 16-bit signed immediate is added to the 32-bit value in register rs
	to produce a 32-bit result.
	If the addition results in 32-bit 2’s complement arithmetic overflow then
	the destination register is not modified and an Integer Overflow
	exception occurs. If it does not overflow, the 32-bit result is placed
	into GPR rt.
		</insn>
		
		<insn mnemonic="addiu" 
		      purpose="Add a constant to a 32-bit integer.">
	The 16-bit signed immediate is added to the 32-bit value in GPR rs and
	the 32-bit arithmetic result is placed into GPR rt. No Integer Overflow
	exception occurs under any circumstances.
		</insn>
		
		<insn mnemonic="addu" 
		      purpose="Add two 32-bit integers">
	The 32-bit word value in GPR rt is added to the 32-bit value in GPR rs
	and the 32-bit arithmetic result is placed into GPR rd. No Integer
	Overflow exception occurs under any circumstances.
		</insn>
		
		<insn mnemonic="and" 
		      purpose="Do a bitwise logical AND.">
	The contents of GPR rs are combined with the contents of GPR rt in a
	bitwise logical AND operation. The result is placed into GPR rd.
		</insn>
		
		<insn mnemonic="andi" 
		      purpose="Do a bitwise logical AND with a constant.">
	The 16-bit immediate is zero-extended to the left and combined with the
	contents of GPR rs in a bitwise logical AND operation. The result is
	placed into GPR rt.
		</insn>
		
		<insn mnemonic="div" 
		      purpose="Divide two 32-bit integers">
	The 32-bit word value in GPR rs is divided by the 32-bit value in GPR
	rt, treating both operands as signed values. The 32-bit quotient is
	placed into special register LO and the 32-bit remainder is placed into
	special register HI.
	No arithmetic exception occurs under any circumstances.
		</insn>
		
		<insn mnemonic="divu" 
		      purpose="Divide two unsigned 32-bit integers">
	The 32-bit word value in GPR rs is divided by the 32-bit value in GPR
	rt, treating both operands as unsigned values. The 32-bit quotient is
	placed into special register LO and the 32-bit remainder is placed into
	special register HI.
	No arithmetic exception occurs under any circumstances.
		</insn>
		
	</group>
	
	<group name="Constant-Manipulation">
	
	</group>
	
	<group name="Comparison">
	
	</group>
	
	<group name="Branching and Jumping">
		<insn mnemonic="beq" 
		      purpose="Compare two registers for equality and do a conditional branch.">
	An 18-bit signed offset (the 16-bit offset field shifted left 2 bits)
	is added to the address of the instruction following the branch (not
	the branch itself), in the branch delay slot, to form a PC-relative
	effective target address.
	If the contents of GPR rs and GPR rt are equal, branch to the effective
	target address after the instruction in the delay slot is executed.
		</insn>
		
		<insn mnemonic="bgez" 
		      purpose="Compare a register against 0 and do a conditional branch.">
	An 18-bit signed offset (the 16-bit offset field shifted left 2 bits)
	is added to the address of the instruction following the branch (not
	the branch itself), in the branch delay slot, to form a PC-relative
	effective target address.
	If the contents of GPR rs are greater than or equal to zero (sign bit is
	0), branch to the effective target address after the instruction in the
	delay slot is executed.
		</insn>
		
		<insn mnemonic="bgezl" 
		      purpose="Compare a register against 0 and do a PC-relative conditional procedure call.">
	Place the return address link in GPR 31. The return link is the address
	of the second instruction following the branch, where execution would
	continue after a procedure call.
	An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is
	added to the address of the instruction following the branch (not the
	branch itself), in the branch delay slot, to form a PC-relative
	effective target address.
	If the contents of GPR rs are greater than or equal to zero (sign bit is
	0), branch to the effective target address after the instruction in the
	delay slot is executed.
		</insn>
		
		<insn mnemonic="bgtz" 
		      purpose="Test a GPR of its contents are greater than 0, then do a PC-relative conditional branch.">
	An 18-bit signed offset (the 16-bit offset field shifted left 2 bits)
	is added to the address of the instruction following the branch (not
	the branch itself), in the branch delay slot, to form a PC-relative
	effective target address.
	If the contents of GPR rs are greater than zero (sign bit is 0 but value
	not zero), branch to the effective target address after the instruction
	in the delay slot is executed.
		</insn>
		
		<insn mnemonic="blez" 
		      purpose="Test a GPR if its contents are less or equal than 0, then do a PC-relative conditional branch.">
	An 18-bit signed offset (the 16-bit offset field shifted left 2 bits)
	is added to the address of the instruction following the branch (not
	the branch itself), in the branch delay slot, to form a PC-relative
	effective target address.
	If the contents of GPR rs are less than or equal to zero (sign bit is 1
	or value is zero), branch to the effective target address after the
	instruction in the delay slot is executed.
		</insn>
		
		<insn mnemonic="bltzal" 
		      purpose="Test a GPR if its contents are less than 0, then do a PC-relative procedure call.">
	Place the return address link in GPR 31. The return link is the address
	of the second instruction following the branch (not the branch itself),
	where execution would continue after a procedure call.
	An 18-bit signed offset (the 16-bit offset field shifted left 2 bits) is
	added to the address of the instruction following the branch, in the
	branch delay slot, to form a PC-relative effective target address.
	If the contents of GPR rs are less than zero (sign bit is 1), branch to
	the effective target address after the instruction in the delay slot is
	executed.
		</insn>
		
		<insn mnemonic="bne" 
		      purpose="Compare two registers for inequality, then do a conditional branch.">
	An 18-bit signed offset (the 16-bit offset field shifted left 2 bits)
	is added to the address of the instruction following the branch (not
	the branch itself), in the branch delay slot, to form a PC-relative
	effective target address.
	If the contents of GPR rs and GPR rt are not equal, branch to the
	effective target address after the instruction in the delay slot is
	executed.
		</insn>
	
	</group>
	
	<group name="Exceptions, Interrupts and Traps">
		<insn mnemonic="syscall" 
		      purpose="Call the operating system">
	Call the operating system.
	Register $v0 contains the number of the system call. 
		</insn>
		<insn mnemonic="break" 
		      purpose="Break to the debugger.">
	Pauses execution and enters the debugger.
		</insn>
	</group>
	
	<group name="Loading">
	
	</group>
	
	<group name="Storing">
	
	</group>
	
	<group name="Data Movement">
	
	</group>
	
	<group name="Floating-Point Instructions">
	
	</group>
</instructions>